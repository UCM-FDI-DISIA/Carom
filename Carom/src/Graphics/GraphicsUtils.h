#pragma once
#include <utility>
#include <box2d/box2d.h>
#include <vector>
#include <SDL.h>
#include "RNG_Manager.h"


using IntPair = std::pair<int,int>;

// Clase con métodos auxiliares para verificar si geometría se solapa, coventir coordenadas de SDL_Rects
class GraphisUtils
{
public:
    // Verifica si dos polígonos se solapan
    static bool doPolygonsOverlap(const std::vector<b2Vec2>& verts1, const std::vector<b2Vec2>& verts2, float radius = 0.01f);
    // Verifica si puntos están dentro de determinada región
    static bool arePointsInsideArea(const std::vector<b2Vec2>& points, const std::vector<b2Vec2>& area);

    // Compute alpha so that pixels outside of shape are set to alpha = 0
    static std::vector<uint8_t> computeAlphaMask(const std::vector<b2Vec2> &polyVerts, const SDL_Rect &rect, float polyRadius = 0.01f);

    /// @brief Generates polygons (vector of vertices) that don't overlap and are area (region) limited. Polygons are generated by generating vertex points from a random distance to a center limited by an interval.
    /// @param minRadius minimum distance of a point from the center
    /// @param maxRadius max distance of a point from the center
    /// @param n number of polygons
    /// @param m number of vertices (max = 8 for box2d)
    /// @param areaX top left x in pixels of a restriction area
    /// @param areaY top left y in pixels of a restriction area
    /// @param areaW width in pixels
    /// @param areaH height in pixels
    /// @param rng random number
    static std::vector<std::vector<b2Vec2>> generateNonOverlappingPolygons(
        float minRadius, float maxRadius, 
        int n, int m, 
        float areaX, float areaY, 
        float areaW, float areaH,
        RNG_Manager* rng);

    /// @brief Generates bounding boxes for polygons. Returns a rect that is clamped by an area and the center of this rect without clamp for propor rendering
    /// @param areaX top left x in pixels of a restriction area
    /// @param areaY top left y in pixels of a restriction area
    /// @param areaW width in pixels
    /// @param areaH height in pixels
    static std::pair<std::vector<SDL_Rect>, std::vector<b2Vec2>> generatePolygonBoundingBoxes(const std::vector<std::vector<b2Vec2>>& polygons, 
    int areaPosX, int areaPosY, 
    int areaWidth, int areaHeight);

    // Genera bounding box de un rectangulo
    static std::pair<SDL_Rect, b2Vec2> generatePolygonBoundingBox(const std::vector<b2Vec2>& polygon, 
        int areaPosX, int areaPosY, 
        int areaWidth, int areaHeight);

    // Calcula el centro de un polígono
    static b2Vec2 calculatePolygonCenter(const std::vector<b2Vec2>& polygon);

    // Devuelve rect que es una porción de otro rect
    static SDL_Rect generatePartialRect(SDL_Rect originalRect, SDL_Rect areaConstrain);

    // Convierte rect con origen en centro en rect top left
    static SDL_Rect getTopLeftRect(IntPair center, IntPair size);

    // Convierte rect top left en origen en centro
    static SDL_Rect getCenterRect(IntPair pos, IntPair size);
    static SDL_Rect getCenterRect(const SDL_Rect& topleftRect);

    // Convert a SDL_Rect into a polygon
    static std::vector<b2Vec2> sdlrectToPolygon(const SDL_Rect& rect);

    // Extrae polígonos de svg
    static std::vector<std::vector<b2Vec2>> extractPolygons(int n, int vert);

    // Method to extract points (x, y) from elements of an SVG group
    // n = number of points
    // name = string part (should be for intance "vert" and the points gathered are vert0, vert1, ... n)
    // group name at SVG map
    static std::vector<b2Vec2> extractPointsFromSVG(int n, int startIdx, const std::string& name, const std::string& group);

    // Debug rect
    static void coutRect(const SDL_Rect& rect);
};